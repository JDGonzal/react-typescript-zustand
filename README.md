# react-typescript-zustand

Based on this site 
[¡No necesitas Redux en React! Aprende a usar Zustand, alternativa sencilla. (Curso de React)](https://www.youtube.com/watch?v=p2wF2wRjcN0)

## Steps to start
1. Install NPM and NODEJS in your system 
  [Nodejs Download](https://nodejs.org/en/download/current/)
2. Starting in the directory called react, run this command:
```bash
	npm create vite@latest react-typescript-zustand
		package name:
		React
		Typescript + SWC
```
3. Change directory and install dependencies
```bash 
cd react-typescript-zustand
pnpm install
```
4. Install the react MUI-material, emotion-react, and emotion-styled
```bash
pnpm install @mui/material @emotion/react @emotion/styled
```
5. Install fontsource/roboto and icons-material
```bash
pnpm install @fontsource/roboto @mui/icons-material -E
```
6. Install as developer the ts-standard
```bash
pnpm install ts-standard -D
```
Note: "ts-standard" is a ruler set to work with Typescript and React.

7. based on the ts-standard do changes in ".eslintrc.cjs", change some values in "eslinrc.cjs" and "tsconfig.json".
8. Restart the eslint server , pressing [Shift]+[Ctlr]+[P], search by "ESLint: Restart".

## Changing the project to start the work

1. Deleting the "App.tsx" all into the first `<>` element.
2. Just add the `<h1>JavaScript Quizz</h1>` in the "App.tsx" file.
3. Import in "main.tsx" the font list of "roboto' 
```js
    import '@fontsource/roboto/300.css';
    import '@fontsource/roboto/400.css';
    import '@fontsource/roboto/500.css';
    import '@fontsource/roboto/700.css';
```
3. Delete the "maintsx" the first line `import React from 'react'`, then remove `<React.StrictMode>`, as well.
4. Creating a new component in "src" directory, called "JavaScriptLogo.tsx", run the `rfce` snippet, and delete the first line.
5. Take the JavaScript log in SVG format from this site [Descarga el logo de HTML5, CSS3 y JavaScript en formato vectorial SVG](https://midu.dev/logos-svg-css-html-javascript/)
6. Change the `<div>` element of the new "JavaScriptLogo.tsx" file.
7. Change the `width={48}` and `height={48}`.
8. Change in "App.tsx".

## Creating a Title of the Header
1. Using a `{Contanier}` from `@mui/material` , in "App.tsx" file, to envolve the `<h1>` element, with a `maxWidth="sm"`.
2. Envolve the `<h1>` element with `Stack`, to put like `direction="row" gap={2} alignItems="center" justifyContent="center"`.
3. Add the `<JavaScriptLogo />` above the `<h1>` element.
4. As weel envolve this `<h1>` element with `Typography`, to use this typographyc, with this `variant="h2" component="h1"`.
5. Finally delete the `<h1>` element.

## Add a page that when clicked retrieves all the questions
1. Add a "data.json" in public directory with questions and answers.
2. Add the "start.tsx" in the "src" directory, run the `rfce` snippet, and delete the first line.
3. Change the `Start` text between `<div>` element by `<Button onClick={() => { }}  variant="contained"></Button>`, element from `@mui/material`.
4. In the middle add the text `Start!` or `¡Vamos a Empezar!`.
5. Add the `<Start/>` below the `</Stack>` in "App.tsx" file.
6. Now install the `zustand`.
```bash
pnpm install zustand -E
```

## Creating the "Store" site to use with *Zustang*
1. Create in the root ("src" directory) a "store" directory.
2. Add a file into "store" directory called "questions.ts".
3. Add in the "src" directory a "types.d.ts" file.
4. Using the "Paste JSON as Code" extension, select all the "data.json" and pressing [Shift]+[Ctrl]+[P], select the "Paste JSON as Code", the name will be "question" then this is the answer:
```js
    // Generated by https://quicktype.io
    export interface Question {
      id:            number;
      question:      string;
      code:          string;
      answers:       string[];
      correctAnswer: number;
    }
```
5. Add to this `interface` two fields:
```js
    export interface Question {
      ...
      userSelectedAnswer?:  number;
      isCorrectUserAnswer?: boolean;
    }
```
6. Import the `interface Question` into "questions.ts" file : 
```js
    import { Question } from  '../types.d';
```
7. Add another interface into "questions.ts" file:
```js
    interface State {
      questions: Question[];
      currentQuestion: number;
      fetchQuestions: (limit: number)=>void;
    }
```
8. Creating the Global estate like:
```js
    export const useQuestionsStore = create<State>(( set)=>{
      return {
        questions:[],
        currentQuestion:0,
        fetchQuestions: async(limit: number)=>{
          console.log(limit);
        }
      }
    });
```
9. Call in "App.tsx" file the Store data:
```js
    const questions = useQuestionsStore(state => state.questions);
```

## Use the questions in the Store, with a manual data
1. Into the "questions.ts" file for the function complete the set, at least with one question (Copied from "data.json" file):
```js
    fetchQuestions: async (limit: number) => {
          console.log(limit);
          set({
            questions: [
              {
                "id": 1,
                "question": "¿Cuál es la salida de este código?",
                "code": "console.log(typeof NaN)",
                "answers": [
                  "undefined",
                  "NaN",
                  "string",
                  "number"
                ],
                "correctAnswer": 3
              }
            ],
          });
          get();
        }
```
2. Call this `fetchQuestions` into "Start.tsx" file:
```js
      const fetchQuestions = useQuestionsStore(state => state.fetchQuestions);
      const handleClick = () => { fetchQuestions(5); }
```
3. Just for test in "App.tsx" file , change the `<Start />` for a conditional:
```js
          {questions.length===0?<Start />:<h1>Juego</h1>}
```
## Using a Data.json into the useQuestionsStore
1. We can `fetch` the json data into `fetchQuestions`:
```js
        fetchQuestions: async (limit: number) => {
          const res = await fetch('http://localhost:5173/data.json');
          const data = await res.json();
        }
```
2. Then use this data to store in a new variable in random order:
```js
        fetchQuestions: async (limit: number) => {
          ...
          const questions = data.sort(() => Math.random() - 0.5).slice(0, limit);
          set({ questions });
        }
```
3. Create a const to export called `LIMIT_QUESTIONS` into "Start.tsx" file.

## Starting with the Game
1. Create in the root a "Game.tsx" component, run the `rfce` snippet, and delete the first line.
2. Add as a first line in  "Game.tsx" file this: `import { IconButton, Stack } from "@mui/material";`.
3. Import the `useQuestionsStore` to put elements in the `function Game()`:
```js
function Game() {
      const questions = useQuestionsStore(state => state.questions);
      const currentQuestion = useQuestionsStore(state => state.currentQuestion);
      )
    }
```
4. Add a `questionInfo` using the previos data from `useQuestionStore`:
```js
    const questionInfo = questions[currentQuestion];
```
5. Add a Component into this "Game.tsx" file:
```js
    const QuestionComponent = ({ info }: { info: Question }) => {
      return (
        <Card variant="outlined">
          <Typography variant="h5">
            { info.question}
          </Typography>
        </Card>
      );
    }
```
6. Return this Component with the `questionInfo` to `info`:
```js
      return (
        <QuestionComponent info={questionInfo} />
      )
```
7. Change the `<h1>Juego</h1>` element by the `<Game/>` component. 

## Improvement the Game component
1. Based on this site [React Syntax Highlighter](https://github.com/react-syntax-highlighter/react-syntax-highlighter), we will run this command 
```bash
pnpm install react-syntax-highlighter -E
```
2. Install the Types in Developer way:
```bash
pnpm install @types/react-syntax-highlighter -D
```
3. Import the `SyntaxHighlighter` and the styles:
```js
    import SyntaxHighlighter  from "react-syntax-highlighter";
    import { gradientDark } from "react-syntax-highlighter/dist/esm/styles/hljs";
```
4. Using this syntaxHighlighter in the "Game" component:
```js
          <SyntaxHighlighter language="JavaScript" style={gradientDark}>
            {info.code}
          </SyntaxHighlighter>
```
5. Add to the `<Card>` element some styles with `sx={{ }}`.
6. Add to the `<Typography>` element some styles.
7. Add the List of with `<List>` element.
8. Add those elements inside the `<List` element: `<ListItem> <ListItemButton> <ListItemText>`, then this is the result:
```js
          <List sx={{ bgcolor: '#333', color:'#efe' }} disablePadding> 
            {info.answers.map((answer, index) => (
              <ListItem key={index} disablePadding divider>
                <ListItemButton>
                  <ListItemText primary={answer} />
                </ListItemButton>
              </ListItem>
            ))}
          </List>
```

## The Uses can select the question and the answer
1. Based on the `userSelectedAnswer?:  number;` from "types.d.ts" file, adding a new method into the "questions.ts" file that is our *store*, "questions.ts" file:
```js
    interface State {
      ...
      selectAnswer: (questionId: number, answerIndex: number) => void;
    }
```
2. This new method put below the `fetchQuestions:`:
```js
        selectAnswer: (questionId: number, answerIndex: number) => {
        }
```
3. the `get()` is all estate into `useQuestionsStore`, then we need to recover only the `questions` array of them:
```js
        selectAnswer: (questionId: number, answerIndex: number) => {
          const {questions }= get();
        }
```
4. Using `structuredClone` we are going to copy this array into a new one:
```js
        selectAnswer: (questionId: number, answerIndex: number) => {
          ... const newQuestions = structuredClone(questions);
        }
```
5. Find the element based on the `questionId`:
```js
        selectAnswer: (questionId: number, answerIndex: number) => {
          ... const questionIndex = newQuestions.findIndex(q => q.id === questionId);
        }
```
6. Get the `questionInfo`, from the `newQuestions` in the position `questionIndex`:
```js
        selectAnswer: (questionId: number, answerIndex: number) => {
          ... const questionInfo = newQuestions[questionIndex];
        }
```
7. Checking the Correct answer:
```js
        selectAnswer: (questionId: number, answerIndex: number) => {
          ... onst isCorrectUserAnswer = questionInfo.correctAnswer === answerIndex;
        }
```
8. Before to update the state, chang the question in the `newQuestions`:
```js
        selectAnswer: (questionId: number, answerIndex: number) => {
          ... 
          newQuestions[questionIndex] ={
            ... questionInfo,
            isCorrectUserAnswer,
            userSelectedAnswer: answerIndex,
          }
        }
```
9. Then update the state, and end of the process in "questions.ts" file:
```js
        selectAnswer: (questionId: number, answerIndex: number) => {
          ... set({questions: newQuestions});
        }
```
10. In the "Game.tsx" file, get the selected answer:
```js
      const selectAnswer = useQuestionsStore(state => state.selectAnswer);
```
11. Create an HandleClick function with anohter function inside:
```js
      const createHandleClick = (answerIndex: number) =>()=> {
        selectAnswer(info.id, answerIndex);
      }
```
12. Add to `<ListItemButton>` element the `onClick` action:
```js
                <ListItemButton onClick={createHandleClick(index)}>
```

## Show the Answer if it is Correct or not
1. Add a Method to show to user if the answer is correct or not:
```js
    const getBackgroundColor = (index: number) => {}
```
2. Inside `getBackgroundColor` destructure the values to validate:
```js
      const { userSelectedAnswer, correctAnswer } = info;
```
3. validate the Answer Selecte in `null` or `undefinied`:
```js
      const getSelectedAnswer=()=> {
        const { userSelectedAnswer} = info;
        return (userSelectedAnswer === null || userSelectedAnswer === undefined);
      }
```
4.  The user not selected anything 
    `if (getSelectedAnswer()) return 'transparent';`.

    If the user selected but it is wrong answer 
    `if (index !== correctAnswer && index !== userSelectedAnswer) return 'transparent';`

    If the user selected the correct answer
    `if (index === correctAnswer) return 'green';`

    If the user selected but it is wrong answer
    `if (index === userSelectedAnswer) return 'red';`
5. Then disabled the click on `<ListItemButton>` element:
```js
            <ListItemButton>
              disabled={!(getSelectedAnswer())}
              ...
            </ListItemButton>
```
6. Install the `canvas-confetti`and the type:
```bash
pnpm install canvas-confetti -E
pnpm i --save-dev @types/canvas-confetti
```
7. Import in "questions.ts" file: `import confetti from 'canvas-confetti';`.
8. Use in the "questions.ts" file into the `selectAnswer` below of `const isCorrectUserAnswer =`
```js
          ...
          const isCorrectUserAnswer = questionInfo.correctAnswer === answerIndex;
          // Show Confetti
          if (isCorrectUserAnswer)confetti();
          ...
```

## Adding the arrows to move into Questions
1. Add in our store "questions.ts" file, two new functions:
```js
    interface State {
      ...
      goNextQuestion: () => void;
      goPreviousQuestion: () => void;
    }
```
2. Control to move forward or back in "questions.ts" file:
```js
        goNextQuestion: () => {
          const { currentQuestion, questions } = get();
          const nextQuestion = currentQuestion + 1;
          if (nextQuestion < questions.length) set({ currentQuestion: nextQuestion });
        },
        goPreviousQuestion: () => {
          const { currentQuestion } = get();
          const previousQuestion = currentQuestion - 1;
          if (previousQuestion >= 0) set({ currentQuestion: previousQuestion });
        }
```
3. Call in "Game.tsx" the new functions:
```js
    function Game() {
      ...
      const goNextQuestion = useQuestionsStore(state => state.goNextQuestion);
      const goPreviousQuestion = useQuestionsStore(state => state.goPreviousQuestion);
      ...
```
4. Add and `<Stack>` element above the `<QuestionComponent>` element
```js
          <Stack direction={'row'} gap={2} alignItems={'center'} justifyContent={'center'}>
          </Stack>
```
5. Lets use the `goPreviosQuestion` and draw a left arrow into the `<Stack>` element.
```js
            <IconButton onClick={goPreviousQuestion} disabled={currentQuestion === 0}>
              <ArrowBackIosNew />
            </IconButton>
```
6. Lets use the `goNextQuestion` and draw a right arrow into the `<Stack>` element.
```js
            <IconButton onClick={goNextQuestion} disabled={currentQuestion >= questions.length - 1}>
              <ArrowForwardIos />
            </IconButton>
```
7. Finally add a message between those arrows to indicate the question number and total of them:
```js
            {currentQuestion+1} / {questions.length}
```
### Note: the `<ArrowBackIosNew/>` and `<ArrowForwardIos/>` requires to import from `@mui/icons-material`.

## Adding a Footer component
1. Add a "Footer.tsx" file in the root, run the `rfce` snippet, and delete the first line.
2. first get the questions of the store: `const questions = useQuestionsStore(state => state.questions);`.
3. Crete three counters: `correctCount`,`wrongCount`, `unanswered`.
4. Move arround the questions using a `forEach`:
```js
      questions.forEach(question => {
        const {userSelectedAnswer: userAnswer, correctAnswer} = question;
        if (userAnswer === null || userAnswer === undefined) unanswered++;
        else {
          if (userAnswer === correctAnswer) correctCount++
          else wrongCount++;
        }
```
5. Return a `<footer>` element:
```js
        <footer style={{ marginTop: '16px', }}>
          <strong>{`✅ ${correctCount} - ❌ ${wrongCount} - ❓ ${unanswered}`}</strong>
        </footer>
```
6. Call this "Footer" component into "Game.tsx" file.
7. improvement the "Footer.tsx" as a custom hook. in a "useQuestionsData.tsx" file
```js
    import { useQuestionsStore } from "../store/questions";
    export const useQuestionData = () => {
      //first get the questions of the store
      const questions = useQuestionsStore(state => state.questions);
      let correctCount = 0;
      let wrongCount = 0;
      let unanswered = 0;
      questions.forEach(question => {
        const { userSelectedAnswer: userAnswer, correctAnswer } = question;
        if (userAnswer === null || userAnswer === undefined) unanswered++;
        else {
          if (userAnswer === correctAnswer) correctCount++
          else wrongCount++;
        }
      })
      return{ correctCount,wrongCount, unanswered};
    }
```
8. Finally move all `Components` to the "components" directory.

## Data persistence with LocalStorage
1. import in "question.ts" file our store from `zustand` the `persist`:
```js
    import { persist } from 'zustand/middleware';
```
2. To envolve with `persist` with `persist()`;
```js
    export const useQuestionsStore = create<State>()(persist((set, get) => {
      return {
        ...
      }
    },{
      name:"questions",
      getStorage: () => localStorage
    }));
```
### Note: just adding this `persist` it store all `state` in the `LocalStorage`.

3. Add a `resetGame` function into the `questions.ts` file, our store.
4. Call the new function and assign to a `const` in "Footer.tsx" file.
```js
    const resetGame = useQuestionsStore(state => state.resetGame);
```
5. Add a reset button in the "Footer.tsx" file, below the `<strong>` element :
```js
          <Button onClick={()=>resetGame()} >
            Resetear juego
          </Button>
```


## React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
   parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    project: ['./tsconfig.json', './tsconfig.node.json'],
    tsconfigRootDir: __dirname,
   },
```

- Replace `plugin:@typescript-eslint/recommended` to `plugin:@typescript-eslint/recommended-type-checked` or `plugin:@typescript-eslint/strict-type-checked`
- Optionally add `plugin:@typescript-eslint/stylistic-type-checked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and add `plugin:react/recommended` & `plugin:react/jsx-runtime` to the `extends` list


